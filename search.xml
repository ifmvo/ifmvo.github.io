<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Andorid 常见的内存泄露及解决办法]]></title>
      <url>https://blog.ifmvo.cn/2017/04/13/avoid-memory-leak-ways/</url>
      <content type="html"><![CDATA[<h2 id="单例造成的内存泄漏"><a href="#单例造成的内存泄漏" class="headerlink" title="单例造成的内存泄漏"></a>单例造成的内存泄漏</h2><p>当调用 getInstance 时，如果传入的 context 是 Activity 的 context。只要这个单例没有被释放，那么这个 Activity 也不会被释放一直到进程退出才会释放。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><div class="line">public class CommUtil &#123;</div><div class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> CommUtil instance;</div><div class="line">   <span class="keyword"> private</span> Context context;</div><div class="line">   <span class="keyword"> private</span> CommUtil(Context context)&#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> CommUtil getInstance(Context mcontext)&#123;</div><div class="line">        if(instance == null)&#123;</div><div class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>CommUtil(mcontext);</div><div class="line">        &#125;</div><div class="line">       <span class="built_in"> return </span>instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>解决方案：能使用Application的Context就不要使用Activity的Content，Application的生命周期伴随着整个进程的周期</p>
</blockquote>
<hr>
<h2 id="非静态内部类创建静态实例造成的内存泄漏"><a href="#非静态内部类创建静态实例造成的内存泄漏" class="headerlink" title="非静态内部类创建静态实例造成的内存泄漏"></a>非静态内部类创建静态实例造成的内存泄漏</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> TestResource mResource = <span class="keyword">null</span>;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="keyword">if</span>(mManager == <span class="keyword">null</span>)&#123;</div><div class="line">            mManager = <span class="keyword">new</span> TestResource();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>解决方案：将非静态内部类修改为静态内部类。（静态内部类不会隐式持有外部类）</p>
</blockquote>
<hr>
<h2 id="Handler造成的内存泄漏"><a href="#Handler造成的内存泄漏" class="headerlink" title="Handler造成的内存泄漏"></a>Handler造成的内存泄漏</h2><p>mHandler是Handler的非静态匿名内部类的实例，所以它持有外部  类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">private</span> TextView mTextView ;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> WeakReference&lt;Context&gt; reference;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">            reference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            MainActivity activity = (MainActivity) reference.get();</div><div class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>)&#123;</div><div class="line">                activity.mTextView.setText(<span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mTextView = (TextView)findViewById(R.id.textview);</div><div class="line">        loadData();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        Message message = Message.obtain();</div><div class="line">        mHandler.sendMessage(message);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>解决方案：创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">private</span> TextView mTextView ;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> WeakReference&lt;Context&gt; reference;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">            reference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            MainActivity activity = (MainActivity) reference.get();</div><div class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>)&#123;</div><div class="line">                activity.mTextView.setText(<span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mTextView = (TextView)findViewById(R.id.textview);</div><div class="line">        loadData();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//...request</span></div><div class="line">        Message message = Message.obtain();</div><div class="line">        mHandler.sendMessage(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="线程造成的内存泄漏"><a href="#线程造成的内存泄漏" class="headerlink" title="线程造成的内存泄漏"></a>线程造成的内存泄漏</h2><p>异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成， 那么将导致Activity的内存资源无法回收，造成内存泄漏。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><div class="line"><span class="literal">new</span> AsyncTask&lt;<span class="literal">Void</span>, <span class="literal">Void</span>, <span class="literal">Void</span>&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    <span class="keyword">protected</span> <span class="literal">Void</span> doInBackground(<span class="literal">Void</span><span class="params">...</span> <span class="keyword">params</span>) &#123;</div><div class="line">        SystemClock.sleep(<span class="number">10000</span>);</div><div class="line">        <span class="keyword">return</span> <span class="built_in">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;.execute();</div><div class="line"></div><div class="line"></div><div class="line"><span class="literal">new</span> <span class="keyword">Thread</span>(<span class="literal">new</span> Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="literal">void</span> run() &#123;</div><div class="line">        SystemClock.sleep(<span class="number">10000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<blockquote>
<p>解决方案：使用 静态内部类，避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> WeakReference&lt;Context&gt; weakReference;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">            weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</div><div class="line">            SystemClock.sleep(<span class="number">10000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void aVoid)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.onPostExecute(aVoid);</div><div class="line">            MainActivity activity = (MainActivity) weakReference.get();</div><div class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//...</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            SystemClock.sleep(<span class="number">10000</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//——————</span></div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</div><div class="line">    <span class="keyword">new</span> MyAsyncTask(<span class="keyword">this</span>).execute();</div></pre></td></tr></table></figure>
<hr>
<h2 id="资源未关闭造成的内存泄漏"><a href="#资源未关闭造成的内存泄漏" class="headerlink" title="资源未关闭造成的内存泄漏"></a>资源未关闭造成的内存泄漏</h2><p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏.</p>
<blockquote>
<p>解决方案：在Activity销毁时及时关闭或者注销</p>
</blockquote>
<hr>
<h2 id="使用了静态的Activity和View"><a href="#使用了静态的Activity和View" class="headerlink" title="使用了静态的Activity和View"></a>使用了静态的Activity和View</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> view;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStaticView</span><span class="params">()</span> </span>&#123;</div><div class="line">    view = findViewById(R.id.sv_button);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View svButton = findViewById(R.id.sv_button);</div><div class="line">svButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        setStaticView();</div><div class="line">        nextActivity();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> Activity activity;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStaticActivity</span><span class="params">()</span> </span>&#123;</div><div class="line">    activity = <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">View saButton = findViewById(R.id.sa_button);</div><div class="line">saButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        setStaticActivity();</div><div class="line">        nextActivity();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>解决方案：应该及时将静态的应用 置为null，而且一般不建议将View及Activity设置为静态</p>
</blockquote>
<hr>
<h2 id="注册了系统的服务，但onDestory未注销"><a href="#注册了系统的服务，但onDestory未注销" class="headerlink" title="注册了系统的服务，但onDestory未注销"></a>注册了系统的服务，但onDestory未注销</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><div class="line">SensorManager sensorManager = getSystemService(SENSOR_SERVICE)<span class="comment">;</span></div><div class="line">Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL)<span class="comment">;</span></div><div class="line">sensorManager.registerListener(this,sensor,SensorManager.SENSOR_DELAY_FASTEST)<span class="comment">;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>解决方案：不需要的时候及时移除监听</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="code"><pre><div class="line">sensorManager.unregisterListener(listener)<span class="comment">;</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="不需要用的监听未移除会发生内存泄露"><a href="#不需要用的监听未移除会发生内存泄露" class="headerlink" title="不需要用的监听未移除会发生内存泄露"></a>不需要用的监听未移除会发生内存泄露</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="comment">//add监听，放到集合里面</span></div><div class="line">tv.getViewTreeObserver().addOnWindowFocusChangeListener(</div><div class="line">  <span class="keyword">new</span> ViewTreeObserver.OnWindowFocusChangeListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</div><div class="line">        <span class="comment">//监听view的加载，view加载出来的时候，计算他的宽高等。</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>解决方案：使用完后，一定要移除这个监听</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">tv</span><span class="selector-class">.getViewTreeObserver</span>()</div><div class="line"><span class="selector-class">.removeOnWindowFocusChangeListener</span>(<span class="selector-tag">this</span>);</div></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="comment">//监听执行完回收对象，不用考虑内存泄漏</span></div><div class="line"><span class="selector-tag">tv</span><span class="selector-class">.setOnClickListener</span>();</div><div class="line"><span class="comment">//add监听，放到集合里面，需要考虑内存泄漏</span></div><div class="line"><span class="selector-tag">tv</span><span class="selector-class">.getViewTreeObserver</span>()</div><div class="line"><span class="selector-class">.addOnWindowFocusChangeListener</span>(this);</div></pre></td></tr></table></figure>
<hr>
<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/402225fce4b2" target="_blank" rel="external">https://www.jianshu.com/p/402225fce4b2</a></p>
<p>如果一不小心，还是让内存泄露了，怎么分析是在哪里泄露了呢？请看：</p>
<p><a href="https://www.jianshu.com/p/2c9fc4e871a4" target="_blank" rel="external">https://www.jianshu.com/p/2c9fc4e871a4</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 封装一个 TopBarBaseActivity by Toolbar]]></title>
      <url>https://blog.ifmvo.cn/2017/04/13/package-topbarbaseactivity-by-toolbar/</url>
      <content type="html"><![CDATA[<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>什么是快速开发嘞，看这个效果</p>
<p><img src="imgs/toolbar4.png" alt="hah"></p>
<p>然而我只用了这么几行代码：</p>
<p><strong><em>MainActivity.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">TopBarBaseActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getContentView</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> R.layout.activity_main;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        setTitle(<span class="string">"陈序员"</span>);</div><div class="line"></div><div class="line">        setTopLeftButton(R.drawable.ic_return_white_24dp, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</div><div class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"陈序员点击了左上角按钮！"</span>, Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        setTopRightButton(<span class="string">"Button"</span>, R.drawable.ic_mine_white_24dp, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</div><div class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"点击了右上角按钮！"</span>, Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>activity_main.xml</em></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用姿势如下：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><div class="line">//设置标题</div><div class="line"><span class="built_in">set</span>Title(<span class="string">"设置"</span>);</div><div class="line"></div><div class="line">//设置左上按钮</div><div class="line"><span class="built_in">set</span>TopLeftButton();</div><div class="line"><span class="built_in">set</span>TopLeftButton(int iconResId, OnClickListener <span class="keyword">on</span>ClickListener);</div><div class="line"></div><div class="line">//设置右上按钮</div><div class="line"><span class="built_in">set</span>TopRightButton(int iconResId, OnClickListener <span class="keyword">on</span>ClickListener);</div><div class="line"><span class="built_in">set</span>TopRightButton(String btnStr, OnClickListener <span class="keyword">on</span>ClickListener);</div><div class="line"><span class="built_in">set</span>TopRightButton(String btnStr, int iconResId, OnClickListener <span class="keyword">on</span>ClickListener);</div></pre></td></tr></table></figure>
<h2 id="为什么用-ToolBar"><a href="#为什么用-ToolBar" class="headerlink" title="为什么用 ToolBar"></a>为什么用 ToolBar</h2><p>ToolBar 出现的目的就是替代 ActionBar，但是 Toolbar 它是个很有个性的妹纸，它通常面目是这样的：</p>
<center><br><img src="imgs/toolbar1.jpg" alt=""><br></center><br>我们修改后的模样：<br><br><br><br>妈的！人家这么有个性的妹纸，长得那么好看，你为什么要给人家搞得破相了呢？<br><br>虽然妹纸长得不错，但是它不实用啊！<br>所以如果想好好的造娃的话，我们就只能自己动手给她整个容了。<br><br>有人又问了：那你找个别的姑娘不就好了吗？<br><br>NO、NO，毕竟 Toolbar 这妹纸还有一些优质的品德的：<br><br>1. 官方提供，符合标准，界面统一。<br>2. 自带点击效果。<br>3. 自带点击热区。<br><br>所以，且看老衲怎么挥一挥刀就实现两全其美的。<br><br><br>### 开始封装<br><br>下面跟着我一步一步的实现我们想要的妹纸。<br><br><strong><em>1. 依赖 appcompat-v7</em></strong><br><br>新建一个项目，因为 Toolbar 是在 appcompat-v7 包下，所以确保已经依赖 appcompat-v7。如果没有请加上，例如：<br><br><figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line"><span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:25.3.0'</span></div></pre></td></tr></table></figure><br><br><strong><em>2. 设置 NoActionBar 主题</em></strong><br><br>由于我们使用 Toolbar 代替 ActionBar，所以先把 ActionBar 去掉，我们通过设置 Application 的 theme 来隐藏，这样项目中所有的界面的 ActionBar 就都隐藏了。<br>先修改 style.xml 中的 AppTheme 继承自 Theme.AppCompat.Light.NoActionBar<br><br><figure class="highlight applescript"><table><tr><td class="code"><pre><div class="line">&lt;style <span class="built_in">name</span>=<span class="string">"AppTheme"</span> parent=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</div><div class="line">    &lt;<span class="built_in">item</span> <span class="built_in">name</span>=<span class="string">"colorPrimary"</span>&gt;@color/colorPrimary&lt;/<span class="built_in">item</span>&gt;</div><div class="line">    &lt;<span class="built_in">item</span> <span class="built_in">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;@color/colorPrimaryDark&lt;/<span class="built_in">item</span>&gt;</div><div class="line">    &lt;<span class="built_in">item</span> <span class="built_in">name</span>=<span class="string">"colorAccent"</span>&gt;@color/colorAccent&lt;/<span class="built_in">item</span>&gt;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure><br><br>AndroidManifest.xml 文件中默认就会设置主题的<br><br><figure class="highlight perl"><table><tr><td class="code"><pre><div class="line">&lt;application</div><div class="line">    android:allowBackup=<span class="string">"true"</span></div><div class="line">    android:icon=<span class="string">"@mipmap/ic_launcher"</span></div><div class="line">    android:label=<span class="string">"@string/app_name"</span></div><div class="line">    android:theme=<span class="string">"@style/AppTheme"</span>&gt;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&lt;<span class="regexp">/application&gt;</span></div></pre></td></tr></table></figure><br><br><strong><em>3. 创建 TopBarBaseActivity</em></strong><br><br>new 一个项目之后会默认创建一个 MainActivity.java 和 activity_main.xml ，然后我们再自己新建两个文件 TopBarBaseActivity.java 和 activity_base_top_bar.xml<br><br><center><br><img src="imgs/toolbar2.png" alt=""><br></center>


<p>然后 TopBarBaseActivity 继承 AppCompatActivity<br>MainActivity 继承 TopBarBaseActivity  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TopBarBaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(<span class="type">R</span>.layout.activity_base_top_bar);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">TopBarBaseActivity</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>4. 把 TopBar 封装在 TopBarBaseActivity</em></strong></p>
<p>首先我们在 activity_base_top_bar.xml 中 添加 Toolbar 布局</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span>  </span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:background</span>=<span class="string">"@color/colorPrimary"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在 TopBarBaseActivity 中获取并初始化设置 Toolbar</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TopBarBaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="type">Toolbar</span> toolbar;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(<span class="type">R</span>.layout.activity_base_top_bar);</div><div class="line"></div><div class="line">        toolbar = (<span class="type">Toolbar</span>) findViewById(<span class="type">R</span>.id.toolbar);</div><div class="line"></div><div class="line">        setSupportActionBar(toolbar);</div><div class="line">        <span class="comment">//设置不显示自带的 Title</span></div><div class="line">        getSupportActionBar().setDisplayShowTitleEnabled(<span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在为止，还是 MainActivity 和 TopBarBaseActivity 显示它们自己的布局，所以我们要实现让 MainActivity 的布局 显示在 TopBarBaseActivity 的布局中，<br>我们先在 activity_base_top_bar.xml 中添加一个 FrameLayout ，这样我们就可以把 MainActivity 的布局解析到 FrameLayout 里面</p>
<figure class="highlight django"><table><tr><td class="code"><pre><div class="line"><span class="xml"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span></div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">    <span class="attr">...</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></div><div class="line">          <span class="attr">...</span></div><div class="line">    &lt;/<span class="attr">android.support.v7.widget.Toolbar</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/viewContent"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后我们修改下 TopBarBaseActivity  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TopBarBaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="type">Toolbar</span> toolbar;</div><div class="line">    <span class="type">FrameLayout</span> viewContent;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(<span class="type">R</span>.layout.activity_base_top_bar);</div><div class="line"></div><div class="line">        toolbar = (<span class="type">Toolbar</span>) findViewById(<span class="type">R</span>.id.toolbar);</div><div class="line">        viewContent = (<span class="type">FrameLayout</span>) findViewById(<span class="type">R</span>.id.viewContent);</div><div class="line"></div><div class="line">        <span class="comment">//初始化设置 Toolbar</span></div><div class="line">        setSupportActionBar(toolbar);</div><div class="line">        getSupportActionBar().setDisplayShowTitleEnabled(<span class="literal">false</span>);</div><div class="line"></div><div class="line">        <span class="comment">//将继承 TopBarBaseActivity 的布局解析到 FrameLayout 里面</span></div><div class="line">        <span class="type">LayoutInflater</span>.from(<span class="type">TopBarBaseActivity</span>.<span class="keyword">this</span>).inflate(getContentView(), viewContent);</div><div class="line">        init(savedInstanceState);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> int getContentView();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> void init(<span class="type">Bundle</span> savedInstanceState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：为了设置两个抽象方法，我们将 TopBarBaseActivity 设置成了抽象类。</p>
</blockquote>
<p>接下来看我们的 MainActivity 自动实现两个父类的抽象方法，并通过 getContentView 方法返回布局 activity_main 的 id。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">TopBarBaseActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> int getContentView() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">R</span>.layout.activity_main;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void init(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在你运行一下项目，我们并没有在 MainActivity 的布局中添加 ToolBar,但是运行出来的效果是 Toolbar 已经存在了。<br><img src="imgs/toolbar3.png" alt=""></p>
<p><strong><em>5. 实现一句话添加标题</em></strong></p>
<p>接下来我们要实现在 MainActivity 里面 <code>setTitle(&quot;标题&quot;);</code>一句话设置标题。</p>
<p>首先我们修改 activity_base_top_bar.xml 布局文件，在 Toolbar 中添加一个 TextView 用来显示标题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">    <span class="attr">...</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></div><div class="line">          <span class="attr">...</span></div><div class="line">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</div><div class="line"></div><div class="line">          <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/tvTitle"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">style</span>=<span class="string">"@style/TextAppearance.AppCompat.Widget.ActionBar.Title"</span></div><div class="line">            <span class="attr">android:textColor</span>=<span class="string">"@android:color/white"</span></div><div class="line">            <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/viewContent"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>再修改 TopBarBaseActivity 添加一个 setTitle 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TopBarBaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    Toolbar toolbar;</div><div class="line">    FrameLayout viewContent;</div><div class="line">    TextView tvTitle;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_base_top_bar);</div><div class="line"></div><div class="line">        toolbar = (Toolbar) findViewById(R.id.toolbar);</div><div class="line">        viewContent = (FrameLayout) findViewById(R.id.viewContent);</div><div class="line">        tvTitle = (TextView) findViewById(R.id.tvTitle);</div><div class="line"></div><div class="line">        <span class="comment">//初始化设置 Toolbar</span></div><div class="line">        setSupportActionBar(toolbar);</div><div class="line">        getSupportActionBar().setDisplayShowTitleEnabled(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="comment">//将继承 TopBarBaseActivity 的布局解析到 FrameLayout 里面</span></div><div class="line">        LayoutInflater.from(TopBarBaseActivity.<span class="keyword">this</span>).inflate(getContentView(), viewContent);</div><div class="line">        init(savedInstanceState);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(title))&#123;</div><div class="line">            tvTitle.setText(title);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getContentView</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Bundle savedInstanceState)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们就可以在 MainActivity 中调用了 setTitle 方法了</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">TopBarBaseActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> int getContentView() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">R</span>.layout.activity_main;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void init(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line">        setTitle(<span class="string">"陈序员"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图：</p>
<p><img src="" alt=""></p>
<p><strong><em>6. 实现一句话添加左上角按钮</em></strong></p>
<p>接下来我们的目标是通过在 MainActivity 中 <code>一句话</code> 实现自定义 TopBar 左上角的 <code>图标</code> 和 <code>点击监听</code>  </p>
<p>首先修改 TopBarBaseActivity, 我们需要造一个接口并声明</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><div class="line">OnClickListener onClickListenerTopLeft;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">OnClickListener</span>&#123;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onClick</span>(<span class="params"></span>)</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后重写 方法并处理点击事件</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (item.getItemId() == android.R.id.home)&#123;</div><div class="line">            onClickListenerTopLeft.onClick();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// true 告诉系统我们自己处理了点击事件</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>再设置一个方法用于设置图标资源 id 和 监听器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setTopLeft</span><span class="params">(<span class="keyword">int</span> iconResId, OnClickListener onClickListener)</span></span>&#123;</div><div class="line">    toolbar.setNavigationIcon(iconResId);</div><div class="line">    <span class="keyword">this</span>.onClickListenerTopLeft = onClickListener;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们就可以在 MainActivity 中这样写</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">TopBarBaseActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> int getContentView() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">R</span>.layout.activity_main;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void init(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line">        setTitle(<span class="string">"陈序员"</span>);</div><div class="line"></div><div class="line">        setTopLeft(<span class="type">R</span>.mipmap.ic_launcher_round, <span class="keyword">new</span> <span class="type">OnClickListener</span>() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            public void onClick() &#123;</div><div class="line">                <span class="type">Toast</span>.makeText(<span class="type">MainActivity</span>.<span class="keyword">this</span>, <span class="string">"陈序员"</span>, <span class="type">Toast</span>.<span class="type">LENGTH_LONG</span>).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行一下试试是不是只需一句话就设置了 TopBar 左按钮的 <code>图标</code> 和 <code>点击事件</code> ！</p>
<p><strong><em>7. 实现一句话添加右上角按钮</em></strong></p>
<p>最后一步，将<br>先创建一个 menu 文件夹和一个 menu 资源文件</p>
<p><img src="" alt=""></p>
<p>内容是这样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/menu_1"</span></div><div class="line">        <span class="attr">android:title</span>=<span class="string">""</span></div><div class="line">        <span class="attr">app:showAsAction</span>=<span class="string">"always"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div></pre></td></tr></table></figure>
<p>继续修改 TopBarBaseActivity ，添加如下代码：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"></div><div class="line">OnClickListener onClickListenerTopRight;</div><div class="line">    </div><div class="line"><span class="keyword">int</span> menuResId;</div><div class="line">String menuStr;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">setTopRightButton</span><span class="params">(String menuStr, <span class="keyword">int</span> menuResId, OnClickListener onClickListener)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.menuResId = menuResId;</div><div class="line">    <span class="keyword">this</span>.menuStr = menuStr;</div><div class="line">    <span class="keyword">this</span>.onClickListenerTopRight = onClickListener;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (menuResId != <span class="number">0</span> || !TextUtils.isEmpty(menuStr))&#123;</div><div class="line">        getMenuInflater().inflate(R.menu.menu_activity_base_top_bar, menu);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onPrepareOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (menuResId != <span class="number">0</span>) &#123;</div><div class="line">        menu.findItem(R.id.menu_1).setIcon(menuResId);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(menuStr))&#123;</div><div class="line">        menu.findItem(R.id.menu_1).setTitle(menuStr);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onPrepareOptionsMenu</span><span class="params">(menu)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们的 MainActivity 再调用 setTopRightButton 方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">TopBarBaseActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getContentView</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> R.layout.activity_main;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        setTitle(<span class="string">"陈序员"</span>);</div><div class="line"></div><div class="line">        setTopLeftButton(R.mipmap.ic_launcher_round, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</div><div class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"陈序员点击了左上角按钮！"</span>, Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        setTopRightButton(<span class="string">"Button"</span>, R.mipmap.ic_launcher_round, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</div><div class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"点击了右上角按钮！"</span>, Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在运行看下效果</p>
<p><img src="" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你说的对啊]]></title>
      <url>https://blog.ifmvo.cn/2017/03/17/beautiful/</url>
      <content type="html"><![CDATA[<p>如果“从零开始”，用什么设计架构的问题属于想得太多做得太少的问题。</p>
<p>从零开始意味着一个项目的主要技术难点是基本功能实现。当每一个功能都需要考虑如何做到的时候，我觉得一般人都没办法考虑如何做好。</p>
<p>因为，所有的优化都是站在最上层进行统筹规划。在这之前，你必须对下层的每一个模块都非常熟悉，进而提炼可复用的代码、规划逻辑流程。</p>
<p><code>所以，如果真的是从零开始，别想太多了.</code></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Android ICE 网络请求完美封装]]></title>
      <url>https://blog.ifmvo.cn/2017/03/16/ice_network/</url>
      <content type="html"><![CDATA[<p>由于公司启动一个新项目，使用 ICE 作为项目系统的中间件，包括后台、移动端iOS、Android 还有 Web 端都使用 ICE，而 Android 端的网络请求部分就是使用 ICE 来实现。</p>
<p>其实我之前也没有听说个 ICE 这个东西，Google 后发现 ICE 在 Android 方面的资料极少，有的话也是一个简单的 Demo，而且官方 Github 上面提供的 Demo 也只是告诉你如何使用，并没有为你提供什么封装好的网络请求库，所以完全由自己从零开始一步一步进行封装，这对于一个刚刚入门的我来说着实不易。</p>
<hr>
<h2 id="ICE为何物？"><a href="#ICE为何物？" class="headerlink" title="ICE为何物？"></a>ICE为何物？</h2><p><code>ZeroC ICE</code> 是 <code>ZeroC</code> 公司的 <code>ICE（Internet Communications Engine）</code>中间件平台。对于客户端和服务端程序的开发提供了很大的便利。</p>
<p><strong>官网自己的描述：</strong></p>
<ul>
<li>灵活</li>
<li>安全、稳定</li>
<li>快速</li>
<li>多语言多平台<code>（Develop in C++, C#, Java, JavaScript, Objective-C, PHP, Python, and Ruby. Deploy on Linux, macOS, Windows, Android, and iOS.）</code></li>
</ul>
<p>目前稳定版本为 3.6 ， 3.7 版本正在持续开发。</p>
<hr>
<h2 id="如何安装？"><a href="#如何安装？" class="headerlink" title="如何安装？"></a>如何安装？</h2><p>无论是 <code>Linux</code> <code>Window</code> 还是 <code>Mac</code> 安装步骤都是很方便的，只要按照官方文档使用几个命令就可以了。请参考<a href="https://doc.zeroc.com/" target="_blank" rel="external">官方文档</a></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>我对 Android 中使用 ICE <strong><em>网络请求部分进行简单封装</em></strong>,可以提供参考.</p>
<p>github 链接:<br><a href="https://github.com/ifmvo/ICEAndroidDemo" target="_blank" rel="external">https://github.com/ifmvo/ICEAndroidDemo</a></p>
<h3 id="调用接口姿势"><a href="#调用接口姿势" class="headerlink" title="调用接口姿势:"></a>调用接口姿势:</h3><p>实现传统 Callback 回调方式<br><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">IceClient</span><span class="selector-class">.getUsers</span>(<span class="string">"ifmvo"</span>, <span class="string">"123456"</span>, new IceClient.Callback&lt;String&gt;() &#123;</div><div class="line">            <span class="variable">@Override</span></div><div class="line">            public void onStart() &#123;</div><div class="line">                <span class="comment">// showLoading();</span></div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="variable">@Override</span></div><div class="line">            public void onFailure(String msg) &#123;</div><div class="line">                <span class="comment">//closeLoading();</span></div><div class="line">                <span class="comment">//showErrorMsg();</span></div><div class="line">                <span class="selector-tag">tvInfo</span><span class="selector-class">.setText</span>(<span class="string">"链接异常信息"</span> + msg);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @<span class="selector-tag">Override</span></div><div class="line">            <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">onSuccess</span>(String result) &#123;</div><div class="line"></div><div class="line">                <span class="comment">//closeLoading();</span></div><div class="line">                <span class="comment">//showResult();</span></div><div class="line">                <span class="selector-tag">tvInfo</span><span class="selector-class">.setText</span>(<span class="string">"返回成功信息"</span> + result);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="添加接口方式"><a href="#添加接口方式" class="headerlink" title="添加接口方式:"></a>添加接口方式:</h3><p>//IceClient.java<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 定义的借口就可以这样写</div><div class="line"> * <span class="doctag">@param</span> username 参数</div><div class="line"> * <span class="doctag">@param</span> password 参数</div><div class="line"> * <span class="doctag">@param</span> callback 回调</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">getUsers</span><span class="params">(String username, String password, <span class="keyword">final</span> Callback callback)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (requestPre(callback) != OK) <span class="keyword">return</span> ;</div><div class="line"></div><div class="line">    helloPrx.begin_getUsers(username, password, <span class="keyword">new</span> Callback_Hello_getUsers() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">(<span class="keyword">int</span> ret, String message)</span> </span>&#123;</div><div class="line">            handleSuccess(message, callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">exception</span><span class="params">(LocalException e)</span> </span>&#123;</div><div class="line">            handleException(callback, e);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> ICE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Thinking in Java 学习笔记]]></title>
      <url>https://blog.ifmvo.cn/2017/03/16/thinking_in_java/</url>
      <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><p>“多任务”操作系统能同时运行多个进程(程序)——但实际是由于 CPU 分时机制的作用,使每个进程都能循环获得自己的 CPU 时间片。但由于轮换速度非常快,使得所有程序好象是在“同时”运行一样。“线程”<br>是进程内部单一的一个顺序控制流。因此,一个进程可能容纳了多个同时执行的线程。</p>
</li>
<li><p>事实上,多线程最主要的一个用途就是构建一个“反应灵敏”的用户界面。</p>
</li>
<li><p>线程机制多少降低了一些计算效率,但无论程序的设计,资源的均衡,还是用户操作的方便性,都从中获得了巨大的利益。当然,如果本来就安装了多块 CPU,那么操作系统能够自行决定为不同的 CPU 分配哪些线程,程序的总体运行速度也会变得更快(所有这些都要求操作系统以及应用程序的支持)。多线程和多任务是充分发挥多处理机系统能力的一种最有效的方式。</p>
</li>
<li><p>CPU 处理一个现有线程集的顺序是不确定的——除非我们亲自介入,并用 Thread 的 setPriority()方法调整它们的优先级。</p>
</li>
<li>普通对象对于垃圾收集来说是一种“公平竞赛”,但线程却并非如此。每个线程都会“注册”自己,所以某处实际存在着对它的一个引用。这样一来,<br>垃圾收集器便只好对它“瞠目以对”了。</li>
</ul>
<blockquote>
<p>个人理解：普通的对象比线程更容易被回收，原因是线程的引用会被存起来。</p>
</blockquote>
<ul>
<li>若某样东西有一个 Runnable 接口,实际只是意味着它有一个 run()方法,但不存在与之相关的任何特殊东<br>西——它不具有任何天生的线程处理能力,这与那些从 Thread 继承的类是不同的。</li>
</ul>
<hr>
<h3 id="Java-如何共享资源"><a href="#Java-如何共享资源" class="headerlink" title="Java 如何共享资源"></a>Java 如何共享资源</h3><ul>
<li><p>对一种特殊的资源——对象中的内存——Java 提供了内建的机制来防止它们的冲突。由于我们通常将数据元<br>素设为从属于 private(私有)类,然后只通过方法访问那些内存,所以只需将一个特定的方法设为<br>synchronized(同步的),便可有效地防止冲突。<strong><em>在任何时刻,只可有一个线程调用特定对象的一个<br>synchronized 方法</em></strong> (尽管那个线程可以调用多个对象的同步方法)</p>
</li>
<li><p>如果只同步其中的一个方法,那么另一个就可以自<br>由忽视对象的锁定,并可无碍地调用。所以必须记住一个重要的规则:对于 <strong><em>访问某个关键共享资源的所有方<br>法,都必须把它们设为 synchronized</em></strong> ,否则就不能正常地工作。</p>
</li>
<li><p>要访问共享资源的每一部分代码都必须封装到一个适当的同步块里。</p>
</li>
</ul>
<blockquote>
<p>在能进入同步块之前,必须在 synchObject 上取得锁。如果已有其他线程取得了这把锁,块便不能进入,必<br>须等候那把锁被释放</p>
</blockquote>
<hr>
<h3 id="synchronized-同步的效率"><a href="#synchronized-同步的效率" class="headerlink" title="synchronized 同步的效率"></a>synchronized 同步的效率</h3><ul>
<li>由于要为同样的数据编写两个方法,所以无论如何都不会给人留下效率很高的印象。看来似乎更好的一种做<br>法是将所有方法都设为自动同步,并完全消除 synchronized 关键字(当然,含有 synchronized run()的例<br>子显示出这样做是很不通的)。但它也揭示出获取一把锁并非一种“廉价”方案——为一次方法调用付出的<br>代价(进入和退出方法,不执行方法主体)至少要累加到四倍,而且根据我们的具体现方案,这一代价还有<br>可能变得更高。所以假如已知一个方法不会造成冲突,最明智的做法便是撤消其中的 synchronized 关键字。</li>
</ul>
<hr>
<h3 id="线程的四个状态"><a href="#线程的四个状态" class="headerlink" title="线程的四个状态"></a>线程的四个状态</h3><ol>
<li>新(New):线程对象已经创建,但尚未启动,所以不可运行。</li>
<li>可运行(Runnable ):意味着一旦时间分片机制有空闲的 CPU 周期提供给一个线程,那个线程便可立即<br>开始运行。因此,线程可能在、也可能不在运行当中,但一旦条件许可,没有什么能阻止它的运行——它既<br>没有“死”掉,也未被“堵塞”。</li>
<li>死(Dead):从自己的 run()方法中返回后,一个线程便已“死”掉。亦可调用 stop()令其死掉,但会<br>产生一个违例——属于 Error 的一个子类(也就是说,我们通常不捕获它)。记住一个违例的“掷”出应当<br>是一个特殊事件,而不是正常程序运行的一部分。所以不建议你使用 stop()(在 Java 1.2 则是坚决反<br>对)。另外还有一个 destroy()方法(它永远不会实现),应该尽可能地避免调用它,因为它非常武断,根<br>本不会解除对象的锁定。</li>
<li>堵塞(Blocked):线程可以运行,但有某种东西阻碍了它。若线程处于堵塞状态,调度机制可以简单地<br>跳过它,不给它分配任何 CPU 时间。除非线程再次进入“可运行”状态,否则不会采取任何操作。</li>
</ol>
<hr>
<h3 id="为什么会堵塞"><a href="#为什么会堵塞" class="headerlink" title="为什么会堵塞?"></a>为什么会堵塞?</h3><p>线程被堵塞可能是由下述五方面的原因造成的:</p>
<ol>
<li>调用 <code>sleep</code>(毫秒数),使线程进入“睡眠”状态。在规定的时间内,这个线程是不会运行的。</li>
<li>用 <code>suspend()</code> 暂停了线程的执行。除非线程收到 <code>resume()</code> 消息,否则不会返回“可运行”状态。</li>
<li>用 <code>wait()</code> 暂停了线程的执行。除非线程收到 <code>nofify()</code> 或者 <code>notifyAll()</code> 消息,否则不会变成“可运行”(是的,这看起来同原因 <code>2</code> 非常相象,但有一个明显的区别是我们马上要揭示的)。</li>
<li>线程正在等候一些 <code>IO</code>(输入输出)操作完成。</li>
<li>线程试图调用另一个对象的 <code>同步</code> 方法,但那个对象处于锁定状态,暂时无法使用。</li>
</ol>
<blockquote>
<p>亦可调用 <code>yield()</code>(Thread 类的一个方法)<code>自动放弃 CPU</code>,以便其他线程能够运行。然而,假如调度机制觉<br>得我们的线程已拥有足够的时间,并跳转到另一个线程,就会发生同样的事情。也就是说,没有什么能防止<br>调度机制重新启动我们的线程。线程被堵塞后,便有一些原因造成它不能继续运行。</p>
</blockquote>
<hr>
<h3 id="等待和通知"><a href="#等待和通知" class="headerlink" title="等待和通知"></a>等待和通知</h3><p><strong><em>无论 sleep()还是 suspend()都不会在自己被调用的时候解除锁定。</em></strong> 需要用到对象锁时,请务必注意这个问题。在另一方面,<strong><em>wait()方法在被调用时却会解除锁定</em></strong>,这意味着可在执行<br>wait()期间调用线程对象中的其他同步方法。但在接着的两个类中,我们看到 run()方法都是“同步”的。<br>在 wait()期间,Peeker 仍然拥有对同步方法的完全访问权限。这是由于 wait()在挂起内部调用的方法时,<br>会解除对象的锁定。<br>我们也可以看到 wait()的两种形式。第一种形式采用一个以毫秒为单位的参数,它具有与 sleep()中相同的<br>含义:暂停这一段规定时间。区别在于在 wait()中,对象锁已被解除,而且能够自由地退出 wait(),因为一<br>个 notify() 可强行使时间流逝。<br>第二种形式不采用任何参数,这意味着 wait()会持续执行,直到 notify()介入为止。而且在一段时间以后,<br>不会自行中止。<br>wait()和 notify()比较特别的一个地方是这两个方法都属于基础类 Object 的一部分,不象 sleep(),<br>suspend()以及 resume()那样属于 Thread 的一部分。尽管这表面看有点儿奇怪——居然让专门进行线程处理<br>的东西成为通用基础类的一部分——但仔细想想又会释然,因为它们操纵的对象锁也属于每个对象的一部<br>分。因此,我们可将一个 wait()置入任何同步方法内部,无论在那个类里是否准备进行涉及线程的处理。事<br>实上,我们能调用 wait()的唯一地方是在一个同步的方法或代码块内部。若在一个不同步的方法内调用<br>wait()或者 notify(),尽管程序仍然会编译,但在运行它的时候,就会得到一个<br>IllegalMonitorStateException(非法监视器状态违例),而且会出现多少有点莫名其妙的一条消息:<br>“current thread not owner”(当前线程不是所有人”。注意 sleep(),suspend()以及resume()都能在不<br>同步的方法内调用,因为它们不需要对锁定进行操作。<br>只能为自己的锁定调用 wait()和 notify()。同样地,仍然可以编译那些试图使用错误锁定的代码,但和往常<br>一样会产生同样的 IllegalMonitorStateException 违例。我们没办法用其他人的对象锁来愚弄系统,但可要<br>求另一个对象执行相应的操作,对它自己的锁进行操作。所以一种做法是创建一个同步方法,令其为自己的<br>对象调用 notify()。</p>
<hr>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>由于线程可能进入堵塞状态,而且由于对象可能拥有“同步”方法——除非同步锁定被解除,否则线程不能<br>访问那个对象——所以 <strong><em>一个线程完全可能等候另一个对象,而另一个对象又在等候下一个对象</em></strong> ,以此类推。<br>这个“等候”链最可怕的情形就是进入封闭状态—— <strong><em>最后那个对象等候的是第一个对象</em></strong> !此时,所有线程都<br>会陷入无休止的相互等待状态,大家都动弹不得。我们将这种情况称为“死锁”。尽管这种情况并非经常出<br>现,但一旦碰到,程序的调试将变得异常艰难。<br>就语言本身来说,尚未直接提供防止死锁的帮助措施,需要我们通过谨慎的设计来避免。如果有谁需要调试<br>一个死锁的程序,他是没有任何窍门可用的。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>何时使用多线程技术,以及何时避免用它,这是我们需要掌握的重要课题。骼它的主要目的是对大量任务进<br>行有序的管理。通过多个任务的混合使用,可以更有效地利用计算机资源,或者对用户来说显得更方便。资<br>源均衡的经典问题是在 IO 等候期间如何利用 CPU。至于用户方面的方便性,最经典的问题就是如何在一个长<br>时间的下载过程中监视并灵敏地反应一个“停止”(stop )按钮的按下。</p>
<p>多线程的主要缺点包括:</p>
<ol>
<li>等候使用共享资源时造成程序的运行速度变慢。</li>
<li>对线程进行管理要求的额外 CPU 开销。</li>
<li>复杂程度无意义的加大,比如用独立的线程来更新数组内每个元素的愚蠢主意。</li>
<li>漫长的等待、浪费精力的资源竞争以及死锁等多线程症状。</li>
</ol>
<p>线程另一个优点是它们用“轻度”执行切换(100 条指令的顺序)取代了“重度”进程场景切换(1000 条指<br>令)。由于一个进程内的所有线程共享相同的内存空间,所以“轻度”场景切换只改变程序的执行和本地变<br>量。而在“重度”场景切换时,一个进程的改变要求必须完整地交换内存空间。<br>线程处理看来好象进入了一个全新的领域,似乎要求我们学习一种全新的程序设计语言——或者至少学习一<br>系列新的语言概念。由于大多数微机操作系统都提供了对线程的支持,所以程序设计语言或者库里也出现了<br>对线程的扩展。</p>
<p>不管在什么情况下,涉及线程的程序设计:</p>
<ol>
<li>刚开始会让人摸不着头脑,要求改换我们传统的编程思路;</li>
<li>其他语言对线程的支持看来是类似的。所以一旦掌握了线程的概念,在其他环境也不会有太大的困难。</li>
</ol>
<p>尽管对线程的支持使 Java 语言的复杂程度多少有些增加,但请不要责怪 Java。毕竟,利用线程可以做许多<br>有益的事情。<br>多个线程可能共享同一个资源(比如一个对象里的内存),这是运用线程时面临的最大的一个麻烦。必须保<br>证多个线程不会同时试图读取和修改那个资源。这要求技巧性地运用 synchronized(同步)关键字。它是一<br>个有用的工具,但必须真正掌握它,因为假若操作不当,极易出现死锁。<br>除此以外,运用线程时还要注意一个非常特殊的问题。由于根据 Java 的设计,它允许我们根据需要创建任意<br>数量的线程——至少理论上如此(例如,假设为一项工程方面的有限元素分析创建数以百万的线程,这对<br>Java 来说并非实际)。然而,我们一般都要控制自己创建的线程数量的上限。因为在某些情况下,大量线程<br>会将场面变得一团糟,所以工作都会几乎陷于停顿。临界点并不象对象那样可以达到几千个,而是在 100 以<br>下。一般情况下,我们只创建少数几个关键线程,用它们解决某个特定的问题。这时数量的限制问题不大。<br>但在较常规的一些设计中,这一限制确实会使我们感到束手束脚。<br>大家要注意线程处理中一个不是十分直观的问题。由于采用了线程“调度”机制,所以通过在 run()的主循<br>环中插入对 sleep()的调用,一般都可以使自己的程序运行得更快一些。这使它对编程技巧的要求非常高,<br>特别是在更长的延迟似乎反而能提高性能的时候。当然,之所以会出现这种情况,是由于在正在运行的线程<br>准备进入“休眠”状态之前,较短的延迟可能造成“sleep()结束”调度机制的中断。这便强迫调度机制将其<br>中止,并于稍后重新启动,以便它能做完自己的事情,再进入休眠状态。必须多想一想,才能意识到事情真<br>正的麻烦程度。</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 命令大全]]></title>
      <url>https://blog.ifmvo.cn/2016/12/25/git/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">git init</td>
<td style="text-align:center">初始化仓库</td>
</tr>
<tr>
<td style="text-align:left">git status</td>
<td style="text-align:center">查看状态</td>
</tr>
<tr>
<td style="text-align:left">git add</td>
<td style="text-align:center">修改添加到缓存</td>
</tr>
<tr>
<td style="text-align:left">git log</td>
<td style="text-align:center">查看日志</td>
</tr>
<tr>
<td style="text-align:left">git brach</td>
<td style="text-align:center">查看分支列表</td>
</tr>
<tr>
<td style="text-align:left">git branch a</td>
<td style="text-align:center">从当前分支另外再新建一个分支</td>
</tr>
<tr>
<td style="text-align:left">git checkout a</td>
<td style="text-align:center">切换到a分支</td>
</tr>
<tr>
<td style="text-align:left">git checkout -b a</td>
<td style="text-align:center">新建并切换（git branch a   +   git checkout a）</td>
</tr>
<tr>
<td style="text-align:left">git branch -d</td>
<td style="text-align:center">删除分支</td>
</tr>
<tr>
<td style="text-align:left">git branch -D</td>
<td style="text-align:center">强制删除分支</td>
</tr>
<tr>
<td style="text-align:left">git tag v1.0</td>
<td style="text-align:center">将当前分支新建一个标签</td>
</tr>
<tr>
<td style="text-align:left">git tag -d <tagname></tagname></td>
<td style="text-align:center">删除tag</td>
</tr>
<tr>
<td style="text-align:left">git checkout v1.0</td>
<td style="text-align:center">切换到v1.0标签</td>
</tr>
<tr>
<td style="text-align:left">git stash</td>
<td style="text-align:center">将当前的修改暂存起来 （git add 过的也可以）</td>
</tr>
<tr>
<td style="text-align:left">git stash list</td>
<td style="text-align:center">查看缓存列表</td>
</tr>
<tr>
<td style="text-align:left">git stash apply</td>
<td style="text-align:center">恢复暂存</td>
</tr>
<tr>
<td style="text-align:left">git stash drop</td>
<td style="text-align:center">删除暂存</td>
</tr>
<tr>
<td style="text-align:left">git stash pop</td>
<td style="text-align:center">恢复并删除（git stash apply  +  git stash drop）</td>
</tr>
<tr>
<td style="text-align:left">git merge develop</td>
<td style="text-align:center">将develop 分支合并到当前分支</td>
</tr>
<tr>
<td style="text-align:left">git push origin –delete <branchname></branchname></td>
<td style="text-align:center">删除远程分支</td>
</tr>
<tr>
<td style="text-align:left">git push origin –delete <tagname></tagname></td>
<td style="text-align:center">删除远程tag</td>
</tr>
<tr>
<td style="text-align:left">git remote show origin</td>
<td style="text-align:center">查看远程和本地的详细状态</td>
</tr>
</tbody>
</table>
<h3 id="GitFlow-Git工作流"><a href="#GitFlow-Git工作流" class="headerlink" title="GitFlow(Git工作流)"></a>GitFlow(Git工作流)</h3><p>一般开发来说,大部分情况下都会拥有两个分支    master    和    develop,他们的职责分别是:</p>
<p>master:永远处在即将发布(production-ready)状态<br>develop:最新的开发状态</p>
<p>确切的说master、develop分支大部分情况下都会保持一致,只有在上线前的测试阶段develop比master的代码要多,一旦测试没问题,准备发布了,这时候会将develop合并到master上。</p>
<p>但是我们发布之后又会进行下一版本的功能开发,开发中间可能又会遇到需要紧急修复bug,一个功能开发完成之后突然需求变动了等情况,所以GitFlow除了以上master和develop两个主要分支以外,还提出了以下三个辅助分支:</p>
<p>feature:开发新功能的分支,基于develop,    完成后merge回develop<br>release:准备要发布版本的分支,用来修复bug,基于develop,完成后    merge回develop和master<br>hotfix:修复master上的问题,    等不及release版本就必须马上上线.基于master,完成后merge回master和develop</p>
<p>什么意思呢?</p>
<p>举个例子,假设我们已经有master和develop两个分支了,这个时候我们准备做一个功能A,第一步我们要做的,就是基于develop分支新建个分支:</p>
<p>git branch feature/A看到了吧,其实就是一个规范,规定了所有开发的功能分支都以feature为前缀。但是这个时候做着做着发现线上有一个紧急的bug需要修复,那赶紧停下手头的工作,立刻切换到master分支,然后再此基础上新建一个分支:</p>
<p>git    branch    hotfix/B代表新建了一个紧急修复分支,修复完成之后直接合并到develop和master,然后发布。然后再切回我们的feature/A分支继续着我们的开发,如果开发完了,那么合并回develop分支,然后在develop分支属于测试环境,跟后端对接并且测试的差不多了,感觉可以发布到正式环境了,这个时候再新建一个release分支:</p>
<p>git branch release/1.0这个时候所有的api、数据等都是正式环境,然后在这个分支上进行最后的测试,发现bug直接进行修改,直到测试ok达到了发布的标准,最后把该分支合并到develop和master然后进行发布。</p>
]]></content>
      
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
