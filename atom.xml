<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈铭卓的博客</title>
  <subtitle>瞅你一天天都干啥了？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ifmvo.github.io/"/>
  <updated>2017-03-22T13:43:46.000Z</updated>
  <id>https://ifmvo.github.io/</id>
  
  <author>
    <name>陈铭卓</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TabLayout 使用详解</title>
    <link href="https://ifmvo.github.io/2017/03/21/tablayout/"/>
    <id>https://ifmvo.github.io/2017/03/21/tablayout/</id>
    <published>2017-03-20T16:00:00.000Z</published>
    <updated>2017-03-22T13:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h3><p>app:tabMode=”scrollable 左对其如果多可滑动” / “fixed 平分”</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性:&quot;&gt;&lt;/a&gt;属性:&lt;/h3&gt;&lt;p&gt;app:tabMode=”scrollable 左对其如果多可滑动” / “fixed 平分”&lt;/p&gt;

    
    </summary>
    
    
      <category term="view" scheme="https://ifmvo.github.io/tags/view/"/>
    
  </entry>
  
  <entry>
    <title>利用 jitpack 将项目插件化</title>
    <link href="https://ifmvo.github.io/2017/03/19/jitpack/"/>
    <id>https://ifmvo.github.io/2017/03/19/jitpack/</id>
    <published>2017-03-18T16:00:00.000Z</published>
    <updated>2017-03-19T01:48:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="img/jitpack.jpg" alt="jitpack"></p>
<h1 id="jitpack-是什么"><a href="#jitpack-是什么" class="headerlink" title="jitpack 是什么"></a>jitpack 是什么</h1><h1 id="为什么用-jitpack"><a href="#为什么用-jitpack" class="headerlink" title="为什么用 jitpack"></a>为什么用 jitpack</h1><h1 id="怎么用-jitpack"><a href="#怎么用-jitpack" class="headerlink" title="怎么用 jitpack"></a>怎么用 jitpack</h1><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line"><span class="keyword">buildscript</span> &#123;</div><div class="line">  <span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">classpath</span> <span class="string">'com.github.dcendents:android-maven-gradle-plugin:1.5'</span> <span class="comment">// Add this line</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;img/jitpack.jpg&quot; alt=&quot;jitpack&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;jitpack-是什么&quot;&gt;&lt;a href=&quot;#jitpack-是什么&quot; class=&quot;headerlink&quot; title=&quot;jitpack 是什么&quot;&gt;&lt;/a&gt;jitp
    
    </summary>
    
    
      <category term="jitpack, 插件化" scheme="https://ifmvo.github.io/tags/jitpack-%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>道理</title>
    <link href="https://ifmvo.github.io/2017/03/17/beautiful/"/>
    <id>https://ifmvo.github.io/2017/03/17/beautiful/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-17T12:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果“从零开始”，用什么设计架构的问题属于想得太多做得太少的问题。</p>
<p>从零开始意味着一个项目的主要技术难点是基本功能实现。当每一个功能都需要考虑如何做到的时候，我觉得一般人都没办法考虑如何做好。</p>
<p>因为，所有的优化都是站在最上层进行统筹规划。在这之前，你必须对下层的每一个模块都非常熟悉，进而提炼可复用的代码、规划逻辑流程。</p>
<p><code>所以，如果真的是从零开始，别想太多了.</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果“从零开始”，用什么设计架构的问题属于想得太多做得太少的问题。&lt;/p&gt;
&lt;p&gt;从零开始意味着一个项目的主要技术难点是基本功能实现。当每一个功能都需要考虑如何做到的时候，我觉得一般人都没办法考虑如何做好。&lt;/p&gt;
&lt;p&gt;因为，所有的优化都是站在最上层进行统筹规划。在这之前
    
    </summary>
    
    
      <category term="道理" scheme="https://ifmvo.github.io/tags/%E9%81%93%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试题</title>
    <link href="https://ifmvo.github.io/2017/03/17/case_interview/"/>
    <id>https://ifmvo.github.io/2017/03/17/case_interview/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-17T12:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于中间件的描述"><a href="#关于中间件的描述" class="headerlink" title="关于中间件的描述"></a>关于中间件的描述</h3><blockquote>
<ul>
<li>中间件应支持标准的协议和接口</li>
<li>中间件可运行与多种硬件和操作系统</li>
<li>跨越网络，硬件，操作系统平台的应用或服务科通过中间件透明交互</li>
<li>中间件并不能提高内核的效率，一般只是负责网络信息的分发处理</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于中间件的描述&quot;&gt;&lt;a href=&quot;#关于中间件的描述&quot; class=&quot;headerlink&quot; title=&quot;关于中间件的描述&quot;&gt;&lt;/a&gt;关于中间件的描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;中间件应支持标准的协议和接口&lt;/li&gt;
&lt;li&gt;中间件
    
    </summary>
    
    
      <category term="面试题" scheme="https://ifmvo.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ICE For Android</title>
    <link href="https://ifmvo.github.io/2017/03/16/ice_network/"/>
    <id>https://ifmvo.github.io/2017/03/16/ice_network/</id>
    <published>2017-03-15T16:00:00.000Z</published>
    <updated>2017-03-19T03:16:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于公司启动一个新项目，使用 ICE 作为项目系统的中间件，包括后台、移动端iOS、Android 还有 Web 端都使用 ICE，而 Android 端的网络请求部分就是使用 ICE 来实现。</p>
<p>其实我之前也没有听说个 ICE 这个东西，Google 后发现 ICE 在 Android 方面的资料极少，有的话也是一个简单的 Demo，而且官方 Github 上面提供的 Demo 也只是告诉你如何使用，并没有为你提供什么封装好的网络请求库，所以完全由自己从零开始一步一步进行封装，这对于一个刚刚入门的我来说着实不易。</p>
<hr>
<h2 id="ICE为何物？"><a href="#ICE为何物？" class="headerlink" title="ICE为何物？"></a>ICE为何物？</h2><p><code>ZeroC ICE</code> 是 <code>ZeroC</code> 公司的 <code>ICE（Internet Communications Engine）</code>中间件平台。对于客户端和服务端程序的开发提供了很大的便利。</p>
<p><strong>官网自己的描述：</strong></p>
<ul>
<li>灵活</li>
<li>安全、稳定</li>
<li>快速</li>
<li>多语言多平台<code>（Develop in C++, C#, Java, JavaScript, Objective-C, PHP, Python, and Ruby. Deploy on Linux, macOS, Windows, Android, and iOS.）</code></li>
</ul>
<p>目前稳定版本为 3.6 ， 3.7 版本正在持续开发。</p>
<hr>
<h2 id="如何安装？"><a href="#如何安装？" class="headerlink" title="如何安装？"></a>如何安装？</h2><p>无论是 <code>Linux</code> <code>Window</code> 还是 <code>Mac</code> 安装步骤都是很方便的，只要按照官方文档使用几个命令就可以了。请参考<a href="https://doc.zeroc.com/" target="_blank" rel="external">官方文档</a></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>我对 Android 中使用 ICE <strong><em>网络请求部分进行简单封装</em></strong>,可以提供参考.</p>
<p>github 链接:<br><a href="https://github.com/ifmvo/ICEAndroidDemo" target="_blank" rel="external">https://github.com/ifmvo/ICEAndroidDemo</a></p>
<h3 id="调用接口姿势"><a href="#调用接口姿势" class="headerlink" title="调用接口姿势:"></a>调用接口姿势:</h3><p>实现传统 Callback 回调方式<br><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">IceClient</span><span class="selector-class">.getUsers</span>(<span class="string">"ifmvo"</span>, <span class="string">"123456"</span>, new IceClient.Callback&lt;String&gt;() &#123;</div><div class="line">            <span class="variable">@Override</span></div><div class="line">            public void onStart() &#123;</div><div class="line">                <span class="comment">// showLoading();</span></div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="variable">@Override</span></div><div class="line">            public void onFailure(String msg) &#123;</div><div class="line">                <span class="comment">//closeLoading();</span></div><div class="line">                <span class="comment">//showErrorMsg();</span></div><div class="line">                <span class="selector-tag">tvInfo</span><span class="selector-class">.setText</span>(<span class="string">"链接异常信息"</span> + msg);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @<span class="selector-tag">Override</span></div><div class="line">            <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">onSuccess</span>(String result) &#123;</div><div class="line"></div><div class="line">                <span class="comment">//closeLoading();</span></div><div class="line">                <span class="comment">//showResult();</span></div><div class="line">                <span class="selector-tag">tvInfo</span><span class="selector-class">.setText</span>(<span class="string">"返回成功信息"</span> + result);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="添加接口方式"><a href="#添加接口方式" class="headerlink" title="添加接口方式:"></a>添加接口方式:</h3><p>//IceClient.java<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 定义的借口就可以这样写</div><div class="line"> * <span class="doctag">@param</span> username 参数</div><div class="line"> * <span class="doctag">@param</span> password 参数</div><div class="line"> * <span class="doctag">@param</span> callback 回调</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">getUsers</span><span class="params">(String username, String password, <span class="keyword">final</span> Callback callback)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (requestPre(callback) != OK) <span class="keyword">return</span> ;</div><div class="line"></div><div class="line">    helloPrx.begin_getUsers(username, password, <span class="keyword">new</span> Callback_Hello_getUsers() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">(<span class="keyword">int</span> ret, String message)</span> </span>&#123;</div><div class="line">            handleSuccess(message, callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">exception</span><span class="params">(LocalException e)</span> </span>&#123;</div><div class="line">            handleException(callback, e);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于公司启动一个新项目，使用 ICE 作为项目系统的中间件，包括后台、移动端iOS、Android 还有 Web 端都使用 ICE，而 Android 端的网络请求部分就是使用 ICE 来实现。&lt;/p&gt;
&lt;p&gt;其实我之前也没有听说个 ICE 这个东西，Google 后发现 
    
    </summary>
    
    
      <category term="ICE" scheme="https://ifmvo.github.io/tags/ICE/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 常用语法及快捷键</title>
    <link href="https://ifmvo.github.io/2017/03/16/markdown/"/>
    <id>https://ifmvo.github.io/2017/03/16/markdown/</id>
    <published>2017-03-15T16:00:00.000Z</published>
    <updated>2017-03-19T03:17:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎使用Markdown编辑器写博客"><a href="#欢迎使用Markdown编辑器写博客" class="headerlink" title="欢迎使用Markdown编辑器写博客"></a>欢迎使用Markdown编辑器写博客</h1><p>本Markdown编辑器使用[StackEdit][6]修改而来，用它写博客，将会带来全新的体验哦：</p>
<ul>
<li><strong>Markdown和扩展Markdown简洁的语法</strong></li>
<li><strong>代码块高亮</strong></li>
<li><strong>图片链接和图片上传</strong></li>
<li><strong><em>LaTex</em>数学公式</strong></li>
<li><strong>UML序列图和流程图</strong></li>
<li><strong>离线写博客</strong></li>
<li><strong>导入导出Markdown文件</strong></li>
<li><strong>丰富的快捷键</strong></li>
</ul>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>加粗    <code>Ctrl + B</code></li>
<li>斜体    <code>Ctrl + I</code></li>
<li>引用    <code>Ctrl + Q</code></li>
<li>插入链接    <code>Ctrl + L</code></li>
<li>插入代码    <code>Ctrl + K</code></li>
<li>插入图片    <code>Ctrl + G</code></li>
<li>提升标题    <code>Ctrl + H</code></li>
<li>有序列表    <code>Ctrl + O</code></li>
<li>无序列表    <code>Ctrl + U</code></li>
<li>横线    <code>Ctrl + R</code></li>
<li>撤销    <code>Ctrl + Z</code></li>
<li>重做    <code>Ctrl + Y</code></li>
</ul>
<h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p>
</blockquote>
<p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考[Github][2].  </p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>Computer</td>
<td>$1600</td>
</tr>
<tr>
<td>Phone</td>
<td>$12</td>
</tr>
<tr>
<td>Pipe</td>
<td>$1</td>
</tr>
</tbody>
</table>
<p>可以使用冒号来定义对齐方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Computer</td>
<td style="text-align:right">1600 元</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Phone</td>
<td style="text-align:right">12 元</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:left">Pipe</td>
<td style="text-align:right">1 元</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<p>###定义列表</p>
<p><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p>
<p>项目３<br>:   定义 C</p>
<p>:   定义 D</p>
<pre><code>&gt; 定义D内容
</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">'''A docstring'''</span></div><div class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></div><div class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></div><div class="line"><span class="meta">... </span>prompt'''</div></pre></td></tr></table></figure></p>
<p>###脚注<br>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p>
<p>[TOC]</p>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见[math.stackexchange.com][1].</p>
<ul>
<li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li>
<li>块级公式：</li>
</ul>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<p>更多LaTex语法请参考 [这儿][3].</p>
<h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</div><div class="line">Note right of 李四: 李四愣了一下，说：</div><div class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</div></pre></td></tr></table></figure>
<p>或者流程图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">st=&gt;start: 开始</div><div class="line">e=&gt;end: 结束</div><div class="line">op=&gt;operation: 我的操作</div><div class="line">cond=&gt;condition: 确认？</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<ul>
<li>关于 <strong>序列图</strong> 语法，参考 [这儿][4],</li>
<li>关于 <strong>流程图</strong> 语法，参考 [这儿][5].</li>
</ul>
<h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p>
<p>博客发表后，本地缓存将被删除。　</p>
<p>用户可以选择 <i class="icon-disk"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p>
</blockquote>
<p>##浏览器兼容</p>
<ol>
<li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li>
<li>IE９以下不支持</li>
<li>IE９，１０，１１存在以下问题<ol>
<li>不支持离线功能</li>
<li>IE9不支持文件导入导出</li>
<li>IE10不支持拖拽文件导入</li>
</ol>
</li>
</ol>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;欢迎使用Markdown编辑器写博客&quot;&gt;&lt;a href=&quot;#欢迎使用Markdown编辑器写博客&quot; class=&quot;headerlink&quot; title=&quot;欢迎使用Markdown编辑器写博客&quot;&gt;&lt;/a&gt;欢迎使用Markdown编辑器写博客&lt;/h1&gt;&lt;p&gt;本Markd
    
    </summary>
    
    
      <category term="Markdown" scheme="https://ifmvo.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in Java 学习笔记</title>
    <link href="https://ifmvo.github.io/2017/03/16/thinking_in_java/"/>
    <id>https://ifmvo.github.io/2017/03/16/thinking_in_java/</id>
    <published>2017-03-15T16:00:00.000Z</published>
    <updated>2017-03-22T13:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><p>“多任务”操作系统能同时运行多个进程(程序)——但实际是由于 CPU 分时机制的作用,使每个进程都能循环获得自己的 CPU 时间片。但由于轮换速度非常快,使得所有程序好象是在“同时”运行一样。“线程”<br>是进程内部单一的一个顺序控制流。因此,一个进程可能容纳了多个同时执行的线程。</p>
</li>
<li><p>事实上,多线程最主要的一个用途就是构建一个“反应灵敏”的用户界面。</p>
</li>
<li><p>线程机制多少降低了一些计算效率,但无论程序的设计,资源的均衡,还是用户操作的方便性,都从中获得了巨大的利益。当然,如果本来就安装了多块 CPU,那么操作系统能够自行决定为不同的 CPU 分配哪些线程,程序的总体运行速度也会变得更快(所有这些都要求操作系统以及应用程序的支持)。多线程和多任务是充分发挥多处理机系统能力的一种最有效的方式。</p>
</li>
<li><p>CPU 处理一个现有线程集的顺序是不确定的——除非我们亲自介入,并用 Thread 的 setPriority()方法调整它们的优先级。</p>
</li>
<li>普通对象对于垃圾收集来说是一种“公平竞赛”,但线程却并非如此。每个线程都会“注册”自己,所以某处实际存在着对它的一个引用。这样一来,<br>垃圾收集器便只好对它“瞠目以对”了。</li>
</ul>
<blockquote>
<p>个人理解：普通的对象比线程更容易被回收，原因是线程的引用会被存起来。</p>
</blockquote>
<ul>
<li>若某样东西有一个 Runnable 接口,实际只是意味着它有一个 run()方法,但不存在与之相关的任何特殊东<br>西——它不具有任何天生的线程处理能力,这与那些从 Thread 继承的类是不同的。</li>
</ul>
<hr>
<h3 id="Java-如何共享资源"><a href="#Java-如何共享资源" class="headerlink" title="Java 如何共享资源"></a>Java 如何共享资源</h3><ul>
<li><p>对一种特殊的资源——对象中的内存——Java 提供了内建的机制来防止它们的冲突。由于我们通常将数据元<br>素设为从属于 private(私有)类,然后只通过方法访问那些内存,所以只需将一个特定的方法设为<br>synchronized(同步的),便可有效地防止冲突。<strong><em>在任何时刻,只可有一个线程调用特定对象的一个<br>synchronized 方法</em></strong> (尽管那个线程可以调用多个对象的同步方法)</p>
</li>
<li><p>如果只同步其中的一个方法,那么另一个就可以自<br>由忽视对象的锁定,并可无碍地调用。所以必须记住一个重要的规则:对于 <strong><em>访问某个关键共享资源的所有方<br>法,都必须把它们设为 synchronized</em></strong> ,否则就不能正常地工作。</p>
</li>
<li><p>要访问共享资源的每一部分代码都必须封装到一个适当的同步块里。</p>
</li>
</ul>
<blockquote>
<p>在能进入同步块之前,必须在 synchObject 上取得锁。如果已有其他线程取得了这把锁,块便不能进入,必<br>须等候那把锁被释放</p>
</blockquote>
<hr>
<h3 id="synchronized-同步的效率"><a href="#synchronized-同步的效率" class="headerlink" title="synchronized 同步的效率"></a>synchronized 同步的效率</h3><ul>
<li>由于要为同样的数据编写两个方法,所以无论如何都不会给人留下效率很高的印象。看来似乎更好的一种做<br>法是将所有方法都设为自动同步,并完全消除 synchronized 关键字(当然,含有 synchronized run()的例<br>子显示出这样做是很不通的)。但它也揭示出获取一把锁并非一种“廉价”方案——为一次方法调用付出的<br>代价(进入和退出方法,不执行方法主体)至少要累加到四倍,而且根据我们的具体现方案,这一代价还有<br>可能变得更高。所以假如已知一个方法不会造成冲突,最明智的做法便是撤消其中的 synchronized 关键字。</li>
</ul>
<hr>
<h3 id="线程的四个状态"><a href="#线程的四个状态" class="headerlink" title="线程的四个状态"></a>线程的四个状态</h3><ol>
<li>新(New):线程对象已经创建,但尚未启动,所以不可运行。</li>
<li>可运行(Runnable ):意味着一旦时间分片机制有空闲的 CPU 周期提供给一个线程,那个线程便可立即<br>开始运行。因此,线程可能在、也可能不在运行当中,但一旦条件许可,没有什么能阻止它的运行——它既<br>没有“死”掉,也未被“堵塞”。</li>
<li>死(Dead):从自己的 run()方法中返回后,一个线程便已“死”掉。亦可调用 stop()令其死掉,但会<br>产生一个违例——属于 Error 的一个子类(也就是说,我们通常不捕获它)。记住一个违例的“掷”出应当<br>是一个特殊事件,而不是正常程序运行的一部分。所以不建议你使用 stop()(在 Java 1.2 则是坚决反<br>对)。另外还有一个 destroy()方法(它永远不会实现),应该尽可能地避免调用它,因为它非常武断,根<br>本不会解除对象的锁定。</li>
<li>堵塞(Blocked):线程可以运行,但有某种东西阻碍了它。若线程处于堵塞状态,调度机制可以简单地<br>跳过它,不给它分配任何 CPU 时间。除非线程再次进入“可运行”状态,否则不会采取任何操作。</li>
</ol>
<hr>
<h3 id="为什么会堵塞"><a href="#为什么会堵塞" class="headerlink" title="为什么会堵塞?"></a>为什么会堵塞?</h3><p>线程被堵塞可能是由下述五方面的原因造成的:</p>
<ol>
<li>调用 <code>sleep</code>(毫秒数),使线程进入“睡眠”状态。在规定的时间内,这个线程是不会运行的。</li>
<li>用 <code>suspend()</code> 暂停了线程的执行。除非线程收到 <code>resume()</code> 消息,否则不会返回“可运行”状态。</li>
<li>用 <code>wait()</code> 暂停了线程的执行。除非线程收到 <code>nofify()</code> 或者 <code>notifyAll()</code> 消息,否则不会变成“可运行”(是的,这看起来同原因 <code>2</code> 非常相象,但有一个明显的区别是我们马上要揭示的)。</li>
<li>线程正在等候一些 <code>IO</code>(输入输出)操作完成。</li>
<li>线程试图调用另一个对象的 <code>同步</code> 方法,但那个对象处于锁定状态,暂时无法使用。</li>
</ol>
<blockquote>
<p>亦可调用 <code>yield()</code>(Thread 类的一个方法)<code>自动放弃 CPU</code>,以便其他线程能够运行。然而,假如调度机制觉<br>得我们的线程已拥有足够的时间,并跳转到另一个线程,就会发生同样的事情。也就是说,没有什么能防止<br>调度机制重新启动我们的线程。线程被堵塞后,便有一些原因造成它不能继续运行。</p>
</blockquote>
<hr>
<h3 id="等待和通知"><a href="#等待和通知" class="headerlink" title="等待和通知"></a>等待和通知</h3><p><strong><em>无论 sleep()还是 suspend()都不会在自己被调用的时候解除锁定。</em></strong> 需要用到对象锁时,请务必注意这个问题。在另一方面,<strong><em>wait()方法在被调用时却会解除锁定</em></strong>,这意味着可在执行<br>wait()期间调用线程对象中的其他同步方法。但在接着的两个类中,我们看到 run()方法都是“同步”的。<br>在 wait()期间,Peeker 仍然拥有对同步方法的完全访问权限。这是由于 wait()在挂起内部调用的方法时,<br>会解除对象的锁定。<br>我们也可以看到 wait()的两种形式。第一种形式采用一个以毫秒为单位的参数,它具有与 sleep()中相同的<br>含义:暂停这一段规定时间。区别在于在 wait()中,对象锁已被解除,而且能够自由地退出 wait(),因为一<br>个 notify() 可强行使时间流逝。<br>第二种形式不采用任何参数,这意味着 wait()会持续执行,直到 notify()介入为止。而且在一段时间以后,<br>不会自行中止。<br>wait()和 notify()比较特别的一个地方是这两个方法都属于基础类 Object 的一部分,不象 sleep(),<br>suspend()以及 resume()那样属于 Thread 的一部分。尽管这表面看有点儿奇怪——居然让专门进行线程处理<br>的东西成为通用基础类的一部分——但仔细想想又会释然,因为它们操纵的对象锁也属于每个对象的一部<br>分。因此,我们可将一个 wait()置入任何同步方法内部,无论在那个类里是否准备进行涉及线程的处理。事<br>实上,我们能调用 wait()的唯一地方是在一个同步的方法或代码块内部。若在一个不同步的方法内调用<br>wait()或者 notify(),尽管程序仍然会编译,但在运行它的时候,就会得到一个<br>IllegalMonitorStateException(非法监视器状态违例),而且会出现多少有点莫名其妙的一条消息:<br>“current thread not owner”(当前线程不是所有人”。注意 sleep(),suspend()以及resume()都能在不<br>同步的方法内调用,因为它们不需要对锁定进行操作。<br>只能为自己的锁定调用 wait()和 notify()。同样地,仍然可以编译那些试图使用错误锁定的代码,但和往常<br>一样会产生同样的 IllegalMonitorStateException 违例。我们没办法用其他人的对象锁来愚弄系统,但可要<br>求另一个对象执行相应的操作,对它自己的锁进行操作。所以一种做法是创建一个同步方法,令其为自己的<br>对象调用 notify()。</p>
<hr>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>由于线程可能进入堵塞状态,而且由于对象可能拥有“同步”方法——除非同步锁定被解除,否则线程不能<br>访问那个对象——所以 <strong><em>一个线程完全可能等候另一个对象,而另一个对象又在等候下一个对象</em></strong> ,以此类推。<br>这个“等候”链最可怕的情形就是进入封闭状态—— <strong><em>最后那个对象等候的是第一个对象</em></strong> !此时,所有线程都<br>会陷入无休止的相互等待状态,大家都动弹不得。我们将这种情况称为“死锁”。尽管这种情况并非经常出<br>现,但一旦碰到,程序的调试将变得异常艰难。<br>就语言本身来说,尚未直接提供防止死锁的帮助措施,需要我们通过谨慎的设计来避免。如果有谁需要调试<br>一个死锁的程序,他是没有任何窍门可用的。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>何时使用多线程技术,以及何时避免用它,这是我们需要掌握的重要课题。骼它的主要目的是对大量任务进<br>行有序的管理。通过多个任务的混合使用,可以更有效地利用计算机资源,或者对用户来说显得更方便。资<br>源均衡的经典问题是在 IO 等候期间如何利用 CPU。至于用户方面的方便性,最经典的问题就是如何在一个长<br>时间的下载过程中监视并灵敏地反应一个“停止”(stop )按钮的按下。</p>
<p>多线程的主要缺点包括:</p>
<ol>
<li>等候使用共享资源时造成程序的运行速度变慢。</li>
<li>对线程进行管理要求的额外 CPU 开销。</li>
<li>复杂程度无意义的加大,比如用独立的线程来更新数组内每个元素的愚蠢主意。</li>
<li>漫长的等待、浪费精力的资源竞争以及死锁等多线程症状。</li>
</ol>
<p>线程另一个优点是它们用“轻度”执行切换(100 条指令的顺序)取代了“重度”进程场景切换(1000 条指<br>令)。由于一个进程内的所有线程共享相同的内存空间,所以“轻度”场景切换只改变程序的执行和本地变<br>量。而在“重度”场景切换时,一个进程的改变要求必须完整地交换内存空间。<br>线程处理看来好象进入了一个全新的领域,似乎要求我们学习一种全新的程序设计语言——或者至少学习一<br>系列新的语言概念。由于大多数微机操作系统都提供了对线程的支持,所以程序设计语言或者库里也出现了<br>对线程的扩展。</p>
<p>不管在什么情况下,涉及线程的程序设计:</p>
<ol>
<li>刚开始会让人摸不着头脑,要求改换我们传统的编程思路;</li>
<li>其他语言对线程的支持看来是类似的。所以一旦掌握了线程的概念,在其他环境也不会有太大的困难。</li>
</ol>
<p>尽管对线程的支持使 Java 语言的复杂程度多少有些增加,但请不要责怪 Java。毕竟,利用线程可以做许多<br>有益的事情。<br>多个线程可能共享同一个资源(比如一个对象里的内存),这是运用线程时面临的最大的一个麻烦。必须保<br>证多个线程不会同时试图读取和修改那个资源。这要求技巧性地运用 synchronized(同步)关键字。它是一<br>个有用的工具,但必须真正掌握它,因为假若操作不当,极易出现死锁。<br>除此以外,运用线程时还要注意一个非常特殊的问题。由于根据 Java 的设计,它允许我们根据需要创建任意<br>数量的线程——至少理论上如此(例如,假设为一项工程方面的有限元素分析创建数以百万的线程,这对<br>Java 来说并非实际)。然而,我们一般都要控制自己创建的线程数量的上限。因为在某些情况下,大量线程<br>会将场面变得一团糟,所以工作都会几乎陷于停顿。临界点并不象对象那样可以达到几千个,而是在 100 以<br>下。一般情况下,我们只创建少数几个关键线程,用它们解决某个特定的问题。这时数量的限制问题不大。<br>但在较常规的一些设计中,这一限制确实会使我们感到束手束脚。<br>大家要注意线程处理中一个不是十分直观的问题。由于采用了线程“调度”机制,所以通过在 run()的主循<br>环中插入对 sleep()的调用,一般都可以使自己的程序运行得更快一些。这使它对编程技巧的要求非常高,<br>特别是在更长的延迟似乎反而能提高性能的时候。当然,之所以会出现这种情况,是由于在正在运行的线程<br>准备进入“休眠”状态之前,较短的延迟可能造成“sleep()结束”调度机制的中断。这便强迫调度机制将其<br>中止,并于稍后重新启动,以便它能做完自己的事情,再进入休眠状态。必须多想一想,才能意识到事情真<br>正的麻烦程度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;“多任务”操作系统能同时运行多个进程(程序)——但实际是由于 CPU 分时机制的作用,使每个进程都能循环获得自己的
    
    </summary>
    
    
      <category term="Java" scheme="https://ifmvo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建博客，分分钟的事儿</title>
    <link href="https://ifmvo.github.io/2017/01/24/how_build_blog_by_hexo/"/>
    <id>https://ifmvo.github.io/2017/01/24/how_build_blog_by_hexo/</id>
    <published>2017-01-23T16:00:00.000Z</published>
    <updated>2017-03-19T03:12:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>程序员刚完成入门，到了迅速成长阶段，为了能够尽快步入大神行列，总想学者别人写个博客，不为别的，就是为了能在学完之后不会左耳进右耳冒，以后还记得曾经学过这么个东西，技术类的博客平台有很多：csdn、简书…. 但是总觉得这种平台的门槛有点低，是个人就能在上面写几笔，终究没有自己搭建的博客好用、上档次。下面就介绍一个好用、上档次的方法：</p>
<h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><p>什么是Hexo？快速、简洁且高效的博客框架.这是Hexo官网对自己的描述。</p>
<p>超快速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p>
<p>支持 Markdown: Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>
<p>一键部署: 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</p>
<p>丰富的插件: Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装Node.js，依次执行以下命令<br><figure class="highlight vim"><table><tr><td class="code"><pre><div class="line">curl http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/creationix/nvm/master/install.<span class="keyword">sh</span> | <span class="keyword">sh</span></div></pre></td></tr></table></figure></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><div class="line">wget -qO- http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/creationix/nvm/master/install.<span class="keyword">sh</span> | <span class="keyword">sh</span></div></pre></td></tr></table></figure>
<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。<br><figure class="highlight cmake"><table><tr><td class="code"><pre><div class="line">nvm <span class="keyword">install</span> stable</div></pre></td></tr></table></figure></p>
<p>开始安装Hexo，如果你网速不好，这可能是个漫长的过程<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><div class="line">npm install -g hexo-<span class="keyword">cli</span></div></pre></td></tr></table></figure></p>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，会自动新建 xxx 文件夹，xxx 文件夹就是你的网站喽。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">hexo init xxx</div><div class="line"><span class="built_in">cd</span> xxx</div><div class="line">npm install</div></pre></td></tr></table></figure></p>
<p>现在在当前文件夹下执行命令<br><figure class="highlight axapta"><table><tr><td class="code"><pre><div class="line">hexo <span class="keyword">server</span></div></pre></td></tr></table></figure></p>
<h3 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;程序员刚完成入门，到了迅速成长阶段，为了能够尽快步入大神行列，总想学者别人写个博客，不为别的，就是为了能在学完之后不会左耳进右耳冒，以后还记
    
    </summary>
    
    
      <category term="轻松搭建博客" scheme="https://ifmvo.github.io/tags/%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>如何学习JS</title>
    <link href="https://ifmvo.github.io/2017/01/23/how_learn%20_js/"/>
    <id>https://ifmvo.github.io/2017/01/23/how_learn _js/</id>
    <published>2017-01-22T16:00:00.000Z</published>
    <updated>2017-03-17T12:21:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文不是我自己写作，只是我在网上看到一篇文章，读起来有趣的很，这篇文章的作者绝对是写文章的好手，作者根据自己学习js的经验得出一些心得分享给大家，下面就是他的这篇文章，好好欣赏吧。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先要说明的是，咱现在不是高手，最多还是一个半桶水，算是入了JS的门</p>
<p>谈不上经验，都是一些教训</p>
<p>这个时候有人要说，“靠，你丫半桶水，凭啥教我们”。您先别急着骂，先听我说</p>
<p>你叫一个大学生去教小学数学，不见得比一个初中生教得好。因为大学生早已经过了那个阶段，都忘记自己怎么走过来的了。而对于初中生，刚好走过那个阶 段，对自己怎么走过来的还记忆犹新，或者还有一些自己的总结。比如，很多高手觉得那本犀牛书入门很好，他们觉得太简单了，但以我的经验来看，它不是入门的 最好选择</p>
<p>先说说学js的条件<br>论条件，咱是文科生，大学专业工商管理，和计算机毛关系都没；有人说英语，读了四年大学，很遗憾，咱还四级没混过；就咱这条件都学得乐呵呵的，您还等啥</p>
<p>当然学习JS也是有门槛的，就是你的html和css至少还比较熟练，您不能连<body>这东东是干啥的都不知道就开始上JS了，学乘除前，学好加减法总是有益无害的</body></p>
<p>再说几点忠告<br>1，不要着急看一些复杂网页效果的代码，这样除了打击你自信心，什么也学不到。没达到一定的武功水平，割了小JJ也学不会葵花宝典的<br>2，别急着加技术交流QQ群，加牛人QQ。如果你找张三丰交流武功，你上去第一句问“丰哥，where is 丹田？”，你会被他一掌劈死的<br>3，看网上什么多少天精通JS，啥啥啥从入门到精通，这种教程直接跳过吧，太多的事实证明，以一种浮躁的心态去做任何事都会以失败而告终<br>4，千万别去弄啥电脑培训，花了钱和时间不说，关键是学不到东西。本来你买两本好书自学3个月能学会的，他们硬是能折腾你两年</p>
<p>推荐几本好书<br>“超毛，你丫吹了半天牛B，还是没说怎么学啊”<br>呵呵，我也没啥特别的办法，只是推荐几本好书。推荐的书，得按先后顺序看。别第一本没看完，就急着上第二本，并不是每次“穿越”都能成功的</p>
<p>第一阶段：《JavaScript DOM编程艺术》<br>看这本书之前，请先确认您对Javascript有个基本的了解，应该知道if else之类的语法，如果不懂，先去看看我第二阶段推荐的Javascript高级程序设计的前三章，记住看三章就别往下看了，回到《JavaScript DOM编程艺术》这本书上来。<br>学习Javascript用《JavaScript DOM编程艺术》来入门最好不过了，老老实实看两遍，看完了你就会对JS有一个大概的了解，整本书都围绕着一个网页效果例子展开，你跟着老老实实敲一篇，敲完之后，你会发现这个效果不是常在网页中看到么，发现自己也能做出来网上的效果了，嘿嘿，小有成就感吧<br>《JavaScript DOM编程艺术》下载地址</p>
<p>第二阶段：《JavaScript高级程序设计》<br>有的书是用来成为经典的，比如犀牛书；还有些书是用来超越经典的，显然这本书就是这种。书中章章经典，由浅入深，其中第6章，关于JS面向对象的解说，没有教程出其右<br>如果有一场满分100分的JS考试，看了《JavaScript DOM编程艺术》能让你拿到20分，那么看完这本书，你就能拿到60分以上了，学完后，你会成就感倍增的，相信我（至少看两遍，推荐三篇，跟着书上的代码一行行的敲）<br>这本书强烈推荐购买，写的太TMD牛逼了，给你带来的价值超过百倍千倍<br>这本书最新的是第三版，貌似就是前些日子出来的，我看的是第二版，第三版相对第二版变动不大，添加了几章内容，价格目前相差10元左右</p>
<p>接下来，恭喜你可以下山了，这个时候可以自己做一些事情了</p>
<p>你可以去Ferris这个教程看看他写的这些效果，看看源代码，怎么样，是不是觉得有一部分很简单了，尝试着跟着他写一写这些效果吧，点这里<br>学技术闭门造车是行不通的，适当的加一两个QQ群交流（注重质量），常去论坛（蓝色理想，CSDN）逛逛，你会经常有些小收获的<br>再有就是看看前辈这些牛人前辈们分享的文章，它会让你的学习事半功倍的，这里是热心人收集的国内一些牛人的博客，个人网站，点这里</p>
<p>第三阶段：《JavaScript语言精粹》和《高性能JavaScript》<br>接下来两本书《JavaScript语言精粹》和《高性能JavaScript》算是JS高级教程的补充，里面有一些内容和JS高级教程重复了，两本书可以同时看，都不厚，可以对前面所学的有一个很好的加强和巩固<br>《JavaScript语言精粹》下载地址<br>《高性能JavaScript》下载地址</p>
<p>第四阶段：《JavaScript DOM高级程序设计》和《JavaScript设计模式》<br>在吃透了前面所说的书之后，接下来两本书的顺序已经无关紧要了，《JavaScript DOM高级程序设计》（注意和《JavaScript 高级程序设计》相区别）和《JavaScript设计模式》，这两本都是重量级的书，能让你的JS技术上一个新的台阶；这两本书前者主修炼外功，后者主修 炼内功，有点想乾坤大挪移和九阳神功的关系；<br>《JavaScript DOM高级程序设计》 首先教你搭建一个类似JQuery的额工具函数库，然后通过讲解几个实际中经常遇到的几个应用例子，会让初学者受益匪浅<br>《JavaScript设计模式》主要讲Javascript的设计模式，说实话，翻译的质量很一般，有些生硬，但已经基本不影响你的学习，看代码完全可以理解出自己的意思<br>这两本书出来一段时间了，可能买不着了，提供下载地址<br>《JavaScript DOM高级程序设计》下载地址，注意有三部分需要下载<br>《JavaScript设计模式》下载地址</p>
<p>最后想说的<br>不安逸，不浮躁。任何学习都不是一蹴而就的，牛B就是一个学习积累的过程，别指望两三个月，你的水平就多么厉害。倚天屠龙记里面的武功最牛B的是张三丰，而不是张无忌。<br>任何工作都需要多种技能，别忽略了html,css等其他知识的学习。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>由于我是在知乎上看到的文章，发帖的人应该也是粘过来的，所以我也不清楚出处是哪里，请勿转发。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文不是我自己写作，只是我在网上看到一篇文章，读起来有趣的很，这篇文章的作者绝对是写文章的好手，作者根据自己学习js的经验得出一些心得分享给
    
    </summary>
    
    
      <category term="JS" scheme="https://ifmvo.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Git 命令大全</title>
    <link href="https://ifmvo.github.io/2016/12/25/git/"/>
    <id>https://ifmvo.github.io/2016/12/25/git/</id>
    <published>2016-12-24T16:00:00.000Z</published>
    <updated>2017-03-17T12:21:15.000Z</updated>
    
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">git init</td>
<td style="text-align:center">初始化仓库</td>
</tr>
<tr>
<td style="text-align:left">git status</td>
<td style="text-align:center">查看状态</td>
</tr>
<tr>
<td style="text-align:left">git add</td>
<td style="text-align:center">修改添加到缓存</td>
</tr>
<tr>
<td style="text-align:left">git log</td>
<td style="text-align:center">查看日志</td>
</tr>
<tr>
<td style="text-align:left">git brach</td>
<td style="text-align:center">查看分支列表</td>
</tr>
<tr>
<td style="text-align:left">git branch a</td>
<td style="text-align:center">从当前分支另外再新建一个分支</td>
</tr>
<tr>
<td style="text-align:left">git checkout a</td>
<td style="text-align:center">切换到a分支</td>
</tr>
<tr>
<td style="text-align:left">git checkout -b a</td>
<td style="text-align:center">新建并切换（git branch a   +   git checkout a）</td>
</tr>
<tr>
<td style="text-align:left">git branch -d</td>
<td style="text-align:center">删除分支</td>
</tr>
<tr>
<td style="text-align:left">git branch -D</td>
<td style="text-align:center">强制删除分支</td>
</tr>
<tr>
<td style="text-align:left">git tag v1.0</td>
<td style="text-align:center">将当前分支新建一个标签</td>
</tr>
<tr>
<td style="text-align:left">git tag -d <tagname></tagname></td>
<td style="text-align:center">删除tag</td>
</tr>
<tr>
<td style="text-align:left">git checkout v1.0</td>
<td style="text-align:center">切换到v1.0标签</td>
</tr>
<tr>
<td style="text-align:left">git stash</td>
<td style="text-align:center">将当前的修改暂存起来 （git add 过的也可以）</td>
</tr>
<tr>
<td style="text-align:left">git stash list</td>
<td style="text-align:center">查看缓存列表</td>
</tr>
<tr>
<td style="text-align:left">git stash apply</td>
<td style="text-align:center">恢复暂存</td>
</tr>
<tr>
<td style="text-align:left">git stash drop</td>
<td style="text-align:center">删除暂存</td>
</tr>
<tr>
<td style="text-align:left">git stash pop</td>
<td style="text-align:center">恢复并删除（git stash apply  +  git stash drop）</td>
</tr>
<tr>
<td style="text-align:left">git merge develop</td>
<td style="text-align:center">将develop 分支合并到当前分支</td>
</tr>
<tr>
<td style="text-align:left">git push origin –delete <branchname></branchname></td>
<td style="text-align:center">删除远程分支</td>
</tr>
<tr>
<td style="text-align:left">git push origin –delete <tagname></tagname></td>
<td style="text-align:center">删除远程tag</td>
</tr>
<tr>
<td style="text-align:left">git remote show origin</td>
<td style="text-align:center">查看远程和本地的详细状态</td>
</tr>
</tbody>
</table>
<h3 id="GitFlow-Git工作流"><a href="#GitFlow-Git工作流" class="headerlink" title="GitFlow(Git工作流)"></a>GitFlow(Git工作流)</h3><p>一般开发来说,大部分情况下都会拥有两个分支    master    和    develop,他们的职责分别是:</p>
<p>master:永远处在即将发布(production-ready)状态<br>develop:最新的开发状态</p>
<p>确切的说master、develop分支大部分情况下都会保持一致,只有在上线前的测试阶段develop比master的代码要多,一旦测试没问题,准备发布了,这时候会将develop合并到master上。</p>
<p>但是我们发布之后又会进行下一版本的功能开发,开发中间可能又会遇到需要紧急修复bug,一个功能开发完成之后突然需求变动了等情况,所以GitFlow除了以上master和develop两个主要分支以外,还提出了以下三个辅助分支:</p>
<p>feature:开发新功能的分支,基于develop,    完成后merge回develop<br>release:准备要发布版本的分支,用来修复bug,基于develop,完成后    merge回develop和master<br>hotfix:修复master上的问题,    等不及release版本就必须马上上线.基于master,完成后merge回master和develop</p>
<p>什么意思呢?</p>
<p>举个例子,假设我们已经有master和develop两个分支了,这个时候我们准备做一个功能A,第一步我们要做的,就是基于develop分支新建个分支:</p>
<p>git branch feature/A看到了吧,其实就是一个规范,规定了所有开发的功能分支都以feature为前缀。但是这个时候做着做着发现线上有一个紧急的bug需要修复,那赶紧停下手头的工作,立刻切换到master分支,然后再此基础上新建一个分支:</p>
<p>git    branch    hotfix/B代表新建了一个紧急修复分支,修复完成之后直接合并到develop和master,然后发布。然后再切回我们的feature/A分支继续着我们的开发,如果开发完了,那么合并回develop分支,然后在develop分支属于测试环境,跟后端对接并且测试的差不多了,感觉可以发布到正式环境了,这个时候再新建一个release分支:</p>
<p>git branch release/1.0这个时候所有的api、数据等都是正式环境,然后在这个分支上进行最后的测试,发现bug直接进行修改,直到测试ok达到了发布的标准,最后把该分支合并到develop和master然后进行发布。</p>
]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;命令&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-a
    
    </summary>
    
    
      <category term="Git" scheme="https://ifmvo.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
